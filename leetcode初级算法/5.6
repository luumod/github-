今天刷了两道题，顺便把昨天忘记记录的两道题补上 :

1. 3的幂  判断一个数字是不是3的幂数 :
例如 3=3^1  9=3^2   n==3^n
这道题看似简单，实际上也一样简单，就我写这一点的功夫，就已经有了两种算法 
1) 试除法:  计算这个数的除以三的余数，如果这个余数是 一 ，则继续，否则直接false ，然后再把它整除3，重复上面的操作
比如 : 15%3=0 15/3=5 5%3!=0->false  所以看似15和3有关系，也可以直接排除
27 : 27%3=0 27/3=9 9%3=0 9/3=3 3%3=0 3/3=1 3%3=0 
2) 最大约数法 :  在32位有符号整数中，最大的3的幂数是 3^19 用这个数字除以n，如果余数为0，则这个数字就是3的幂数
3）暴力穷举法 :  32位整数，遍历每个数字的3的i次方，如果等于n，则匹配成功


bool isPowerOfThree(int n){
    //试除法,
    // if (n==0)
    //     return false;
    // while (n!=1){
    //     if (n%3!=0)
    //         return false;
    //     n=n/3;
    // }
    // return true;
    最大约数法
    // if (n<=0)
    //     return false;
    // if (1162261467%n==0)
    //     return true;
    // else
    //     return false;
    一行代码
    // return n > 0 && 1162261467 % n == 0;
    暴力列举
    for (int i=0;i<31;i++){
        if (n==pow(3,i))
            return true;
    }
    return false;
}

2.罗马数字转数字 : 
详细见力扣   https://leetcode-cn.com/problems/roman-to-integer/
输入一个罗马数字，把罗马数字转换为整数 ：
罗马数字有 I V X L D C M
看官方题解可以得到  ；
给定一个罗马数字 : XXIV  10+10-1+5=24  XXVI 10+10+5+1=26
可以得到一个小的规律 : 如果前面的罗马数字表示的数字大于后面的罗马数字表示的数字，则说明执行加法操作
否则，前面的小于后面的数字，则说明执行减法操作(我太佩服他们了，怎么想出来的)

思路 ： 先设置一个存储整数的数组，字母减字母，得到两个字母之间的ASCII的差值，把它当下标
字符型罗马数字先得到它的长度，遍历每一个罗马数字，根据下标得到他这一位上的值，然后比较他和下一位数字的关系，
前小后大，减这个数字，前大后小，加这个数字

int romanToInt(char * s){
    //判断前一个字符比后一个大还是小
    int num[26];    //26个字符
    //你可能会跟我有相同的疑问，这个地方啥意思，据我所知，如果你要输入一个字符，并且查找它所对应的值，
    //因为他们是不同的类型，所以必须类型转换，但是利用ASCII码相减可以快速字符型下标转换整数下标
    num['I'-'A']=1;
    num['V'-'A']=5;
    num['X'-'A']=10;
    num['L'-'A']=50;
    num['C'-'A']=100;
    num['D'-'A']=500;
    num['M'-'A']=1000;
    int len=strlen(s),value=0,ans=0;
    for (int i=0;i<len;i++){
        value=num[s[i]-'A'];
        if (i<len-1 && value<num[s[i+1]-'A'])
            ans-=value;
        else{
            ans+=value;
        }
    }
    return ans;
}





